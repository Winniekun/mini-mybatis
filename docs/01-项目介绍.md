# Mini-MyBatis 项目学习指南

## 🎯 项目目标

通过从零开始手写一个简化版的MyBatis框架，深入理解MyBatis的核心原理和设计思想，达到面试级别的源码熟悉度。

## 📚 学习路径

### 第一阶段：基础架构 ✅

**核心类**：
- `Configuration` - 全局配置中心
- `SqlSession` - 会话接口
- `SqlSessionFactory` - 会话工厂
- `MappedStatement` - SQL语句映射

**设计模式**：
- 单例模式（Configuration）
- 工厂模式（SqlSessionFactory）

**关键理解**：
- MyBatis的整体架构
- 配置信息的组织方式
- 会话的生命周期

---

### 第二阶段：配置解析 ✅

**核心类**：
- `XMLConfigBuilder` - 主配置文件解析器
- `XMLMapperBuilder` - Mapper文件解析器
- `SqlSessionFactoryBuilder` - 工厂建造者

**技术点**：
- DOM4J XML解析
- Builder建造者模式
- 配置文件到Java对象的映射

**关键理解**：
- MyBatis如何解析配置文件
- MappedStatement的创建过程
- namespace与Mapper接口的关联

---

### 第三阶段：SQL执行器 ✅

**核心类**：
- `Executor` - 执行器接口
- `SimpleExecutor` - 简单执行器
- `StatementHandler` - JDBC语句处理器

**技术点**：
- JDBC封装
- PreparedStatement参数设置
- SQL占位符解析（#{} → ?）

**关键理解**：
- SQL执行的完整流程
- 三种执行器的区别（Simple、Reuse、Batch）
- Statement的创建和管理

---

### 第四阶段：结果集映射 ✅

**核心类**：
- `ResultSetHandler` - 结果集处理器

**技术点**：
- ResultSet遍历
- Java反射创建对象
- 字段名到属性名的映射
- 类型转换
- 下划线命名 ↔ 驼峰命名

**关键理解**：
- 数据库字段如何映射到Java对象
- 自动映射的实现原理
- 类型处理器的作用

---

### 第五阶段：动态代理（核心！）✅

**核心类**：
- `MapperProxy` - Mapper代理类
- `MapperProxyFactory` - 代理工厂
- `MapperRegistry` - Mapper注册中心

**技术点**：
- JDK动态代理
- InvocationHandler
- 方法签名解析
- 接口方法到SQL的映射

**关键理解**：
- ⭐ **这是MyBatis最核心的功能！**
- Mapper接口如何"无实现类"执行SQL
- 动态代理的工作原理
- 方法调用如何转换为SQL执行

**面试重点**：
```
Q: MyBatis的Mapper接口是如何工作的？
A: 通过JDK动态代理。当调用Mapper接口方法时：
   1. MapperProxy拦截方法调用
   2. 根据接口全限定名+方法名构建statementId
   3. 从Configuration获取对应的MappedStatement
   4. 通过SqlSession执行SQL
   5. 返回结果
```

---

### 第六阶段：插件机制 ✅

**核心类**：
- `Interceptor` - 拦截器接口
- `Plugin` - 插件代理
- `InterceptorChain` - 拦截器链
- `Invocation` - 方法调用信息
- `SQLLogInterceptor` - SQL日志拦截器（示例）

**技术点**：
- 责任链模式
- 动态代理包装
- 方法拦截

**关键理解**：
- MyBatis的四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）
- 插件如何拦截方法调用
- 拦截器的执行顺序

**面试重点**：
```
Q: MyBatis的插件原理？
A: 通过动态代理+责任链模式实现：
   1. 为四大对象创建代理
   2. 拦截器组成责任链
   3. 方法调用时依次执行拦截器
   4. 拦截器可以修改参数、返回值
```

---

### 第七阶段：缓存机制 ✅

**核心类**：
- `Cache` - 缓存接口
- `PerpetualCache` - 永久缓存
- `CacheKey` - 缓存键

**技术点**：
- 装饰器模式
- HashMap缓存实现
- 缓存键的生成算法

**关键理解**：
- 一级缓存：SqlSession级别，默认开启
- 二级缓存：Mapper级别，需要配置
- 缓存失效的时机

**面试重点**：
```
Q: MyBatis的一级缓存和二级缓存？
A: 
一级缓存：
- SqlSession级别
- 默认开启，无法关闭
- commit/rollback/close会清空
- 避免同一个会话的重复查询

二级缓存：
- Mapper级别（namespace）
- 需要手动开启
- 跨SqlSession共享
- 需要注意并发和脏读问题
```

---

## 🔍 核心流程分析

### MyBatis完整执行流程

```
1. 初始化阶段
   ├─ 加载配置文件（mybatis-config.xml）
   ├─ 解析配置（XMLConfigBuilder）
   ├─ 创建Configuration对象
   ├─ 解析Mapper文件（XMLMapperBuilder）
   ├─ 创建MappedStatement对象
   ├─ 注册Mapper接口（MapperRegistry）
   └─ 创建SqlSessionFactory

2. 执行阶段
   ├─ 打开SqlSession
   ├─ 获取Mapper代理对象（MapperProxy）
   ├─ 调用Mapper方法
   ├─ MapperProxy拦截方法调用
   ├─ 查找对应的MappedStatement
   ├─ 创建Executor执行器
   ├─ Executor创建StatementHandler
   ├─ StatementHandler准备Statement
   ├─ 设置参数（ParameterHandler）
   ├─ 执行SQL
   ├─ 处理结果集（ResultSetHandler）
   ├─ 返回结果
   └─ 关闭SqlSession
```

### 设计模式应用总结

| 设计模式 | 应用场景 | 核心类 |
|---------|---------|--------|
| 工厂模式 | 创建SqlSession | SqlSessionFactory |
| 建造者模式 | 构建复杂对象 | SqlSessionFactoryBuilder, MappedStatement.Builder |
| 单例模式 | 全局配置 | Configuration |
| 代理模式 | Mapper接口、插件 | MapperProxy, Plugin |
| 模板方法模式 | SQL执行流程 | Executor |
| 责任链模式 | 插件拦截 | InterceptorChain |
| 装饰器模式 | 缓存功能增强 | Cache |

---

## 💡 面试常见问题

### 1. MyBatis的核心组件有哪些？

**答**：
- **SqlSessionFactory**：会话工厂，全局唯一
- **SqlSession**：会话对象，执行SQL的入口
- **Executor**：执行器，真正执行SQL
- **StatementHandler**：语句处理器，封装JDBC操作
- **ParameterHandler**：参数处理器，设置SQL参数
- **ResultSetHandler**：结果处理器，处理返回结果
- **MappedStatement**：SQL语句映射
- **Configuration**：全局配置中心

### 2. #{} 和 ${} 的区别？

**答**：
- **#{}**：预编译，使用PreparedStatement，参数用?占位，可以防止SQL注入
- **${}**：字符串替换，直接拼接到SQL中，有SQL注入风险

### 3. MyBatis如何防止SQL注入？

**答**：
使用#{}占位符，底层使用PreparedStatement的参数绑定，不是字符串拼接。

### 4. Mapper接口为什么不需要实现类？

**答**：
通过JDK动态代理创建代理对象，方法调用被MapperProxy拦截，根据方法签名找到对应的SQL执行。

### 5. MyBatis的插件可以拦截哪些对象？

**答**：
四大对象：
- Executor：执行器
- StatementHandler：语句处理器
- ParameterHandler：参数处理器
- ResultSetHandler：结果处理器

### 6. MyBatis的执行器有哪几种？

**答**：
- **SimpleExecutor**：简单执行器，每次执行都创建新的Statement
- **ReuseExecutor**：复用执行器，复用Statement
- **BatchExecutor**：批量执行器，批量执行SQL

---

## 📖 学习建议

1. **按阶段学习**：不要跳着学，每个阶段都有其意义
2. **对比源码**：实现一个功能后，对比MyBatis源码的实现
3. **画流程图**：理清楚各个组件之间的调用关系
4. **写测试用例**：通过测试验证理解
5. **做笔记**：记录关键点和疑问
6. **多问为什么**：为什么要这样设计？有什么好处？

---

## 🚀 下一步

1. 运行测试用例，验证功能
2. 对比MyBatis源码，找出差异
3. 阅读MyBatis官方文档
4. 尝试实现更多高级功能

---

## 📞 常见问题

**Q: 为什么要手写MyBatis？**  
A: 看源码容易迷失在细节中，手写可以：
- 理解核心流程
- 掌握设计思想
- 面试更自信

**Q: 这个项目和真实MyBatis的区别？**  
A: 
- 简化了很多细节处理
- 没有实现所有功能
- 但核心原理是一致的

**Q: 学完这个项目能达到什么水平？**  
A:
- 面试能详细讲解MyBatis原理
- 能看懂MyBatis源码
- 能处理MyBatis相关问题

---

**继续努力！你已经掌握了MyBatis的核心原理！** 🎉

